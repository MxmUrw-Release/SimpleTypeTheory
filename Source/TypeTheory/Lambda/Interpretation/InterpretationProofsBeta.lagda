\begin{code}[hide]

{-# OPTIONS --cubical #-}

open import TypeTheory.Lambda.Base
  renaming (_√ó_ to _|√ó|_ )
open import TypeTheory.Lambda.Param
open import TypeTheory.Lambda.IParam

module TypeTheory.Lambda.Interpretation.InterpretationProofsBeta {‚Ñì ‚Ñì'} {iparam : IParam ‚Ñì ‚Ñì'} where
open IParam iparam

open import TypeTheory.Lambda.Base.CCCProofs {iparam = iparam}
open import TypeTheory.Lambda.Base.CCCid {iparam = iparam}
open import TypeTheory.Lambda.Interpretation.Interpretation {iparam = iparam}
open import TypeTheory.Lambda.Interpretation.InterpretationProofsWeak {iparam = iparam}

open Category ùíû
open isCCC CCC
open hasTerminal Terminal
open hasProducts Products
open hasExponentials Exponentials

open LambdaParam param
open import TypeTheory.Lambda.Core {param = param}
open import TypeTheory.Lambda.Typing {param = param}
open import TypeTheory.Lambda.Reduction {param = param}

\end{code}
\begin{theorem}[Semantics of substitution]\label{th:ISub}
  The interpretation of a substitution $T\:[\:F\:]‚áì$ is a composition
  of the interpretations of the context morphism $F$ and the judgement $T$.
  \[
  \begin{tikzcd}[column sep=huge, row sep=huge]
    \CC{Œî} \ar[r, "\MM{F}"] \ar[rd, swap, "\JJ{T\,[\,F\,]‚áì}"] & \CC{Œì} \ar[d, "\JJ{T}"] \\
    & \TT{œÑ}
  \end{tikzcd}
  \]
\begin{code}
ISub : ‚àÄ{t œÑ}  -> {Œì : Ctx m} -> {Œî : Ctx n}
               -> (T : Œì ‚ä¢ t :: œÑ)
               -> (F : Œî ‚áâ Œì)
               -> J‚ü¶ T [ F ]‚áì ‚üß == M‚ü¶ F ‚üß ‚óá J‚ü¶ T ‚üß
\end{code}
\end{theorem}
\begin{proof}
  Similar to the proof of Theorem \ref{th:subst}, this proof uses Lemma \ref{th:Iext} for the case of $t$ being a lambda term.
\end{proof}
\begin{code}[hide]
ISub {m} {n} {cconst c} {œÑ} {Œì} {Œî} T F =
  let
      p = cconst‚áë T
      p2 = cconst‚áë {Œì = Œî} (T [ F ]‚áì)

      P1 : ! == M‚ü¶ F ‚üß ‚óá !
      P1 = !-uprop

      P2 : T=‚ü¶ p2 ‚üß == T=‚ü¶ p ‚üß
      P2 = cong T=‚ü¶_‚üß (Ty-isSet (Œπ (ctype c)) œÑ p2 p)

      P3 : ! ‚óá Mc c ‚óá T=‚ü¶ p2 ‚üß == M‚ü¶ F ‚üß ‚óá !! ‚óá Mc c ‚óá T=‚ü¶ p ‚üß
      P3 ùíä = P1 ùíä ‚óá Mc c ‚óá P2 ùíä

      P4 = (M‚ü¶ F ‚üß ‚óá ! ‚óá Mc c ‚óá T=‚ü¶ p ‚üß)           ‚â°‚ü® asc (M‚ü¶ F ‚üß ‚óá !) (Mc c) T=‚ü¶ p ‚üß ‚ü©
           (M‚ü¶ F ‚üß ‚óá !) ‚óá (Mc c ‚óá T=‚ü¶ p ‚üß)         ‚â°‚ü® asc M‚ü¶ F ‚üß ! (Mc c ‚óá T=‚ü¶ p ‚üß) ‚ü©
           M‚ü¶ F ‚üß ‚óá (! ‚óá (Mc c ‚óá T=‚ü¶ p ‚üß))         ‚â°‚ü® sym (asc ! (Mc c) (T=‚ü¶ p ‚üß)) |ctx| (M‚ü¶ F ‚üß ‚óá_) ‚ü©
           M‚ü¶ F ‚üß ‚óá ((! ‚óá Mc c) ‚óá T=‚ü¶ p ‚üß)         ‚àé

  in P3 ‚àô P4

ISub {m} {n} {V j} {œÑ} {Œì} {Œî} T (f , F) =
  let
      i , Œîi=œÑ , i=j = V‚áë T

      P : J‚ü¶ Jmapt (cong f i=j) (JmapT Œîi=œÑ (F i)) ‚üß == M‚ü¶ (f , F) ‚üß ‚óá (œÄ·µ¢ i ‚óá T=‚ü¶ Œîi=œÑ ‚üß)

      P = J‚ü¶ Jmapt (cong f i=j) (JmapT Œîi=œÑ (F i)) ‚üß        ‚â°‚ü® Imapt= (cong f i=j) (JmapT Œîi=œÑ (F i)) ‚ü©
          J‚ü¶ JmapT Œîi=œÑ (F i) ‚üß                             ‚â°‚ü® sym (p-unit-r (cong T‚ü¶_‚üß Œîi=œÑ) J‚ü¶ F i ‚üß J‚ü¶ JmapT Œîi=œÑ (F i) ‚üß (Œª ùíä -> J‚ü¶ JmapT= (F i) (JmapT Œîi=œÑ (F i)) Œîi=œÑ ùíä ‚üß )) ‚ü©
          J‚ü¶ F i ‚üß ‚óá T=‚ü¶ Œîi=œÑ ‚üß                             ‚â°‚ü® sym (‚ü™,‚ü´-prop (Œª j -> J‚ü¶ F j ‚üß) i) |ctx| (_‚óá T=‚ü¶ Œîi=œÑ ‚üß) ‚ü©
          ‚ü™ (Œª j -> J‚ü¶ F j ‚üß) ‚ü´ ‚óá œÄ·µ¢ i ‚óá T=‚ü¶ Œîi=œÑ ‚üß        ‚â°‚ü® asc ‚ü™ (Œª j -> J‚ü¶ F j ‚üß) ‚ü´ (œÄ·µ¢ i) (T=‚ü¶ Œîi=œÑ ‚üß) ‚ü©
          ‚ü™ (Œª j -> J‚ü¶ F j ‚üß) ‚ü´ ‚óá (œÄ·µ¢ i ‚óá T=‚ü¶ Œîi=œÑ ‚üß)      ‚àé

  in P

ISub {m} {n} {Œõ œÉ t} {Œπ x} {Œì} {Œî} T F = ‚ä•-elim (lambdaNoFunc T)
ISub {m} {n} {Œõ œÉ‚ÇÇ t} {œÉ ‚áí œà} {Œì} {Œî} ŒõT F =
  let
      T , œÉ=œÉ‚ÇÇ = addVarLambda ŒõT

      P = J‚ü¶ Jmapt (cong (Œª Œæ -> Œõ Œæ (t [ extT (fst F) ])) œÉ=œÉ‚ÇÇ) (Œõ‚áì (T [ extM œÉ F ]‚áì)) ‚üß

                  ‚â°‚ü® Imapt= ((cong (Œª Œæ -> Œõ Œæ (t [ extT (fst F) ])) œÉ=œÉ‚ÇÇ)) (Œõ‚áì (T [ extM œÉ F ]‚áì)) ‚ü©

          J‚ü¶ (Œõ‚áì (T [ extM œÉ F ]‚áì)) ‚üß                               ‚â°‚ü® IŒõ‚áì (T [ extM œÉ F ]‚áì) ‚ü©
          C=‚ü¶ tail= œÉ Œî ‚üß ‚óá curry J‚ü¶ (T [ extM œÉ F ]‚áì) ‚üß           ‚â°‚ü® ISub T (extM œÉ F) |ctx| (Œª Œæ -> C=‚ü¶ tail= œÉ Œî ‚üß ‚óá curry Œæ) ‚ü©
          C=‚ü¶ tail= œÉ Œî ‚üß ‚óá curry (M‚ü¶ extM œÉ F ‚üß ‚óá J‚ü¶ T ‚üß)           ‚â°‚ü® Iext F œÉ |ctx| (Œª Œæ -> C=‚ü¶ tail= œÉ Œî ‚üß ‚óá curry (Œæ ‚óá J‚ü¶ T ‚üß)) ‚ü©

          C=‚ü¶ tail= œÉ Œî ‚üß ‚óá curry (((C=‚ü¶ sym (tail= œÉ Œî) ‚üß ‚óá M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) √ó√ó id) ‚óá J‚ü¶ T ‚üß)

                  ‚â°‚ü® curry-comp (C=‚ü¶ sym (tail= œÉ Œî) ‚üß ‚óá M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) J‚ü¶ T ‚üß |ctx| (C=‚ü¶ tail= œÉ Œî ‚üß ‚óá_) ‚ü©

          C=‚ü¶ tail= œÉ Œî ‚üß ‚óá ((C=‚ü¶ sym (tail= œÉ Œî) ‚üß ‚óá M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) ‚óá curry J‚ü¶ T ‚üß)

                  ‚â°‚ü® sym (asc C=‚ü¶ tail= œÉ Œî ‚üß (C=‚ü¶ sym (tail= œÉ Œî) ‚üß ‚óá M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) (curry J‚ü¶ T ‚üß)) ‚ü©

          C=‚ü¶ tail= œÉ Œî ‚üß ‚óá (C=‚ü¶ sym (tail= œÉ Œî) ‚üß ‚óá M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) ‚óá curry J‚ü¶ T ‚üß

                  ‚â°‚ü® asc C=‚ü¶ sym (tail= œÉ Œî) ‚üß M‚ü¶ F ‚üß C=‚ü¶ tail= œÉ Œì ‚üß |ctx| (Œª Œæ -> C=‚ü¶ tail= œÉ Œî ‚üß ‚óá Œæ ‚óá curry J‚ü¶ T ‚üß) ‚ü©

          C=‚ü¶ tail= œÉ Œî ‚üß ‚óá (C=‚ü¶ sym (tail= œÉ Œî) ‚üß ‚óá (M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß)) ‚óá curry J‚ü¶ T ‚üß

                  ‚â°‚ü® sym (asc C=‚ü¶ tail= œÉ Œî ‚üß C=‚ü¶ sym (tail= œÉ Œî) ‚üß (M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß)) |ctx| (_‚óá curry J‚ü¶ T ‚üß) ‚ü©

          C=‚ü¶ tail= œÉ Œî ‚üß ‚óá C=‚ü¶ sym (tail= œÉ Œî) ‚üß ‚óá (M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) ‚óá curry J‚ü¶ T ‚üß

                  ‚â°‚ü® C=‚ü¶‚üß-inv (tail= œÉ Œî) |ctx| (Œª Œæ -> Œæ ‚óá (M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) ‚óá curry J‚ü¶ T ‚üß) ‚ü©

          id ‚óá (M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) ‚óá curry J‚ü¶ T ‚üß

                  ‚â°‚ü® unit-l (M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) |ctx| (_‚óá curry J‚ü¶ T ‚üß) ‚ü©

          (M‚ü¶ F ‚üß ‚óá C=‚ü¶ tail= œÉ Œì ‚üß) ‚óá curry J‚ü¶ T ‚üß

                  ‚â°‚ü® asc M‚ü¶ F ‚üß C=‚ü¶ tail= œÉ Œì ‚üß (curry J‚ü¶ T ‚üß) ‚ü©

          M‚ü¶ F ‚üß ‚óá (C=‚ü¶ tail= œÉ Œì ‚üß ‚óá curry J‚ü¶ T ‚üß)

                  ‚àé
  in P
ISub {m} {n} {app t s} {œÑ} {Œì} {Œî} TS F =
  let
      œÉ , T , S = app‚áë TS

      T[F] = T [ F ]‚áì
      S[F] = S [ F ]‚áì

      P = J‚ü¶ app‚áì T[F] S[F] ‚üß                        ‚â°‚ü® Iapp‚áì T[F] S[F] ‚ü©
          ‚ü® J‚ü¶ T[F] ‚üß , J‚ü¶ S[F] ‚üß ‚ü© ‚óá ev              ‚â°‚ü® ISub T F |ctx| (Œª Œæ -> ‚ü® Œæ , J‚ü¶ S[F] ‚üß ‚ü© ‚óá ev) ‚ü©
          ‚ü® M‚ü¶ F ‚üß ‚óá J‚ü¶ T ‚üß , J‚ü¶ S[F] ‚üß ‚ü© ‚óá ev        ‚â°‚ü® ISub S F |ctx| (Œª Œæ -> ‚ü® M‚ü¶ F ‚üß ‚óá J‚ü¶ T ‚üß , Œæ ‚ü© ‚óá ev) ‚ü©
          ‚ü® M‚ü¶ F ‚üß ‚óá J‚ü¶ T ‚üß , M‚ü¶ F ‚üß ‚óá J‚ü¶ S ‚üß ‚ü© ‚óá ev  ‚â°‚ü® sym (comp-‚ü®,‚ü© M‚ü¶ F ‚üß J‚ü¶ T ‚üß J‚ü¶ S ‚üß) |ctx| (_‚óá ev) ‚ü©
          M‚ü¶ F ‚üß ‚óá ‚ü® J‚ü¶ T ‚üß , J‚ü¶ S ‚üß ‚ü© ‚óá ev           ‚â°‚ü® asc M‚ü¶ F ‚üß ‚ü® J‚ü¶ T ‚üß , J‚ü¶ S ‚üß ‚ü© ev ‚ü©
          M‚ü¶ F ‚üß ‚óá (‚ü® J‚ü¶ T ‚üß , J‚ü¶ S ‚üß ‚ü© ‚óá ev)         ‚àé

  in P

\end{code}


%----------------------------------------------------------------------
\section{Soundness}
%----------------------------------------------------------------------
The interpretation of $\lamto$ terms into categories should be compatible
with the internal notion of $Œ≤$-equality: Terms which are considered
equal should have the same interpretation. Such a property is called
soundness.

$Œ≤$-equality is based on reduction, therefore the main challenge is to prove
that a single reduction step does not change the interpretation of a term.


\begin{code}[hide]

mapCtxArr=d : ‚àÄ{n t œÑ œÖ} -> {Œì : Ctx n} -> {T : Œì ‚ä¢ t :: œÑ} -> {U : Œì ‚ä¢ t :: œÖ} -> (p : œÑ == œÖ)
              -> PathP (Œª i -> Œì ‚ä¢ t :: p i) T U -> PathP (Œª i -> C‚ü¶ Œì ‚üß ‚áÅ T‚ü¶ p i ‚üß) J‚ü¶ T ‚üß J‚ü¶ U ‚üß
mapCtxArr=d p P i = J‚ü¶ P i ‚üß

trans-d : ‚àÄ{‚Ñì ‚Ñì'} {A : ùí∞ ‚Ñì} {B : A -> ùí∞ ‚Ñì'} {x y : A} -> {u v : B x} -> {w : B y} -> (L : PathP (Œª _ -> B x) u v) -> (p : x == y) -> PathP (Œª i -> B (p i)) v w -> PathP (Œª i -> B (p i)) u w
trans-d {B = B} {v = v} L p R i = primComp (Œª j -> B (p (i ‚àß j))) _
                        (Œª { j (i = i0) -> L (~ j)
                           ; j (i = i1) -> R j})
                        (v)

Jntl : ‚àÄ{n œÑ} -> {Œì : Ctx n} -> (T : Œì ‚ä© œÑ) -> J‚ü¶ T ‚üßtl == J‚ü¶ snd T ‚üß
Jntl _ = refl


B : ‚àÄ{n} -> (Œì : Ctx n) -> Ty -> ùí∞ ‚Ñì'
B {n} (Œì) x = C‚ü¶ Œì ‚üß ‚áÅ T‚ü¶ x ‚üß

JApp= : ‚àÄ{n w r s œÑ œà Œæ} -> {Œì : Ctx n} -> (œà=Œæ : œà == Œæ)
        -> (W‚ÇÅ : Œì ‚ä¢ w :: œà ‚áí œÑ) -> (W‚ÇÇ : Œì ‚ä¢ w :: Œæ ‚áí œÑ)
        -> (R : Œì ‚ä¢ r :: œà) -> (S‚ÇÇ : Œì ‚ä¢ s :: Œæ)
        -> (P1 : PathP (Œª i -> B Œì (œà=Œæ i ‚áí œÑ)) J‚ü¶ W‚ÇÅ ‚üß J‚ü¶ W‚ÇÇ ‚üß)
        -> (P2 : PathP (Œª i -> B Œì (œà=Œæ i)) J‚ü¶ R ‚üß J‚ü¶ S‚ÇÇ ‚üß)
        -> ‚ü® J‚ü¶ W‚ÇÅ ‚üß , J‚ü¶ R ‚üß ‚ü© ‚óá ev == ‚ü® J‚ü¶ W‚ÇÇ ‚üß , J‚ü¶ S‚ÇÇ ‚üß ‚ü© ‚óá ev
JApp= _ _ _ _ _ P1 P2 i = ‚ü® P1 i , P2 i ‚ü© ‚óá ev



SingleStepTl : ‚àÄ{n u œÑ} -> {Œì : Ctx n} ->  (T : Œì ‚ä© œÑ) -> (w : fst T ‚Ü¶ u) -> J‚ü¶ T ‚üßtl == J‚ü¶ JStep-tl T w ‚üßtl

\end{code}

\begin{theorem}
  The interpretation of a well typed term does not change after a single
  reduction step.
\begin{code}
SingleStep : ‚àÄ{t u œÑ}  -> {Œì : Ctx n}
                       -> (w : t ‚Ü¶ u)
                       -> (T : Œì ‚ä¢ t :: œÑ)
                       -> J‚ü¶ T ‚üß == J‚ü¶ JStep w T ‚üß
\end{code}
\end{theorem}
\begin{proof}
The proof works by induction on the definition of a single reduction step.
The most interesting case is that of $\AIC{rbeta}$, it involves substition
of the first variable. In order to prove it, we have to use the properties
described in Lemma \ref{lem:ISub0} and Theorem \ref{th:ISub}.
\end{proof}

\begin{code}[hide]
SingleStep {n} {t} {u} (w) T = SingleStepTl (t , T) w



-- We have this abstract, for else the checker gets confused by the normalized term
abstract
  fstTy= : ‚àÄ{a b c d} -> a ‚áí b == c ‚áí d -> a == c
  fstTy= p = cong ‚áí1 p

AppT : ‚àÄ{n} -> (Œì : Ctx n) -> (r s : Term) -> (œÑ : Ty) -> ùí∞‚ÇÄ
AppT Œì r s œÑ = Œ£ (Œª œÉ -> (Œì ‚ä¢ r :: œÉ ‚áí œÑ) |√ó| (Œì ‚ä¢ s :: œÉ))


abstract
  breakApp : ‚àÄ{n t r s œÑ} -> {Œì : Ctx n} -> (T : Œì ‚ä¢ t :: œÑ) -> (t == app r s) -> Œ£ (Œª (œÉRS : AppT Œì r s œÑ) -> J‚ü¶ T ‚üß == ‚ü® J‚ü¶ fst (snd œÉRS) ‚üß , (J‚ü¶ snd (snd œÉRS) ‚üß) ‚ü© ‚óá ev)
  breakApp {n} {t} {r} {s} {œÑ} {Œì} T t=rs =
    let
        RS = Jmapt t=rs T
        œÉ , R , S = app‚áë (RS)

        P1 : J‚ü¶ T ‚üß == ‚ü® J‚ü¶ R ‚üß , (J‚ü¶ S ‚üß) ‚ü© ‚óá ev
        P1 ùíä = J‚ü¶ Jmapt= T RS t=rs ùíä ‚üß

    in (œÉ , R , S) , P1




SingleStepTl {n} {œÑ = œà} {Œì} T (rbeta {œÉ‚ÇÇ} {r} {s} {t} {u} t=Œõrs u=r[0/s]) =
  let
      -- -- left side judgements
      (œÉ , ŒõR , S) , PZ0 = breakApp (snd T) t=Œõrs
      R , _ = addVarLambda ŒõR


      -- right side judgements
      U = JStep-tl T (rbeta t=Œõrs u=r[0/s])
      R[0/S] = Jmapt-tl U u=r[0/s]


      R[Sub‚ÇÄS] : Œì ‚ä© œà
      R[Sub‚ÇÄS] = r [ 0 / s ] , R [ Sub‚ÇÄ S ]‚áì

      -- Proof chain
      P1 : J‚ü¶ R [ Sub‚ÇÄ S ]‚áì ‚üß == M‚ü¶ Sub‚ÇÄ S ‚üß ‚óá J‚ü¶ R ‚üß
      P1 = ISub R (Sub‚ÇÄ S)

      P2 : M‚ü¶ Sub‚ÇÄ S ‚üß ‚óá J‚ü¶ R ‚üß == ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß , J‚ü¶ S ‚üß ‚ü© ‚óá ((curry J‚ü¶ R ‚üß √ó√ó id) ‚óá ev)
      P2 ùíä = ISub‚ÇÄ S ùíä ‚óá sym (curry-prop J‚ü¶ R ‚üß) ùíä

      P3 =
          ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß , J‚ü¶ S ‚üß ‚ü© ‚óá ((curry J‚ü¶ R ‚üß √ó√ó id) ‚óá ev)
                                                                          ‚â°‚ü® sym (asc ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß , J‚ü¶ S ‚üß ‚ü© (curry J‚ü¶ R ‚üß √ó√ó id) ev) ‚ü©
          ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß , J‚ü¶ S ‚üß ‚ü© ‚óá (curry J‚ü¶ R ‚üß √ó√ó id) ‚óá ev
                                                                          ‚â°‚ü® ‚ü®,‚ü©-comp C=‚ü¶ tail= œÉ Œì ‚üß J‚ü¶ S ‚üß (curry J‚ü¶ R ‚üß) id |ctx| (_‚óá ev) ‚ü©
          ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß ‚óá curry J‚ü¶ R ‚üß , J‚ü¶ S ‚üß ‚óá id ‚ü© ‚óá ev
                                                                          ‚â°‚ü® unit-r J‚ü¶ S ‚üß |ctx| (Œª Œæ -> ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß ‚óá curry J‚ü¶ R ‚üß , Œæ ‚ü© ‚óá ev) ‚ü©
          ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß ‚óá curry J‚ü¶ R ‚üß , J‚ü¶ S ‚üß ‚ü© ‚óá ev
                                                                          ‚àé

      P4 : J‚ü¶ U ‚üßtl == J‚ü¶ R[Sub‚ÇÄS] ‚üßtl
      P4 = cong J‚ü¶_‚üßtl (Jmapt=tl (U) R[Sub‚ÇÄS] u=r[0/s])

      P7 : J‚ü¶ T ‚üßtl == ‚ü® C=‚ü¶ tail= œÉ Œì ‚üß ‚óá curry J‚ü¶ R ‚üß , J‚ü¶ S ‚üß ‚ü© ‚óá ev
      P7 = PZ0


      Q1 : J‚ü¶ T ‚üßtl == J‚ü¶ JStep-tl T (rbeta t=Œõrs u=r[0/s]) ‚üßtl
      Q1 = P7 ‚àô (sym P3) ‚àô (sym P2) ‚àô (sym P1) ‚àô sym (Jntl R[Sub‚ÇÄS]) ‚àô (sym P4)

  in Q1
SingleStepTl {n} {.(Œõ _ _)} {Œπ X} {Œì} (_ , ŒõR) (rlam {œÑ} {r} {s} r‚Ü¶s) = ‚ä•-elim (lambdaNoFunc ŒõR)
SingleStepTl {n} {.(Œõ _ _)} {œà ‚áí Œæ} {Œì} (_ , ŒõR) (rlam {œÑ} {r} {s} r‚Ü¶s) =
  let

      R , œà=œÑ = addVarLambda ŒõR

      S‚ÇÅ = JStep r‚Ü¶s R

      ŒõS = JStep (rlam r‚Ü¶s) ŒõR

      S‚ÇÇ , œà=œÑ‚ÇÇ = addVarLambda ŒõS


      P1 : J‚ü¶ R ‚üß == J‚ü¶ S‚ÇÅ ‚üß
      P1 = SingleStep r‚Ü¶s R

      P2 : J‚ü¶ S‚ÇÅ ‚üß == J‚ü¶ S‚ÇÇ ‚üß
      P2 i = J‚ü¶ JmapT= S‚ÇÅ S‚ÇÇ refl i ‚üß

      P4 :(curry J‚ü¶ R ‚üß) == (curry J‚ü¶ S‚ÇÇ ‚üß)
      P4 i = curry ((P1 ‚àô P2) i)


      P7 : J‚ü¶ ŒõR ‚üß == J‚ü¶ ŒõS ‚üß
      P7 i = C=‚ü¶ tail= œÑ Œì ‚üß ‚óá P4 i

  in P7


SingleStepTl {n} {u} {œÑ} {Œì} T (rapp1 {r} {s} {t} {u} {v = w} r‚Ü¶s t=rw u=sw) =
  let

      RW : Œì ‚ä© œÑ
      RW = Jmapt-tl T t=rw
      œà , R , W‚ÇÅ = app‚áë (snd RW)

      S = JStep r‚Ü¶s R

      U  = JStep-tl T (rapp1 r‚Ü¶s t=rw u=sw)
      SW = Jmapt-tl U u=sw
      Œæ , S‚ÇÇ , W‚ÇÇ = app‚áë (snd SW)

      œà=Œæ : œà == Œæ
      œà=Œæ = uniqueT W‚ÇÅ W‚ÇÇ


      œàœÑ=ŒæœÑ : œà ‚áí œÑ == Œæ ‚áí œÑ
      œàœÑ=ŒæœÑ = cong (_‚áí œÑ) œà=Œæ

      P1 : J‚ü¶ T ‚üßtl == J‚ü¶ RW ‚üßtl
      P1 = cong J‚ü¶_‚üßtl (Jmapt=tl T RW t=rw)


      P4 : J‚ü¶ R ‚üß == J‚ü¶ S ‚üß
      P4 = SingleStep r‚Ü¶s R

      P5 : PathP (Œª i -> Œì ‚ä¢ s :: œàœÑ=ŒæœÑ i) S S‚ÇÇ
      P5 = JmapT= S S‚ÇÇ (œàœÑ=ŒæœÑ)

      P6 : PathP (Œª i -> C‚ü¶ Œì ‚üß ‚áÅ T‚ü¶ œàœÑ=ŒæœÑ i ‚üß) J‚ü¶ S ‚üß J‚ü¶ S‚ÇÇ ‚üß
      P6 i = J‚ü¶ P5 i ‚üß

      B : Ty -> ùí∞ ‚Ñì'
      B x = C‚ü¶ Œì ‚üß ‚áÅ T‚ü¶ x ‚üß

      P7 : PathP (Œª i -> B (œàœÑ=ŒæœÑ i)) J‚ü¶ R ‚üß J‚ü¶ S‚ÇÇ ‚üß
      P7 = trans-d {B = B} P4 œàœÑ=ŒæœÑ P6

      P8 : PathP (Œª i -> B (œà=Œæ i)) J‚ü¶ W‚ÇÅ ‚üß J‚ü¶ W‚ÇÇ ‚üß
      P8 i = J‚ü¶ JmapT= W‚ÇÅ W‚ÇÇ œà=Œæ i ‚üß

      Q1 : J‚ü¶ U ‚üßtl == J‚ü¶ SW ‚üßtl
      Q1 = cong J‚ü¶_‚üßtl (Jmapt=tl U SW u=sw)

      Q2 : J‚ü¶ snd RW ‚üß == J‚ü¶ snd SW ‚üß
      Q2 i = ‚ü® P7 i , P8 i ‚ü© ‚óá ev


      Q3 = P1 ‚àô Jntl RW ‚àô Q2 ‚àô sym (Jntl SW) ‚àô sym Q1

  in Q3

SingleStepTl {n} {u} {œÑ} {Œì} T (rapp2 {r} {s} {t} {u} {w} r‚Ü¶s t=wr u=ws) =
  let
      WR : Œì ‚ä© œÑ
      WR = Jmapt-tl T t=wr
      œà , W‚ÇÅ , R = app‚áë (snd WR)

      S = JStep r‚Ü¶s R

      U  = JStep-tl T (rapp2 r‚Ü¶s t=wr u=ws)
      WS = Jmapt-tl U u=ws
      Œæ , W‚ÇÇ , S‚ÇÇ = app‚áë (snd WS)

      p00 : œà ‚áí œÑ == Œæ ‚áí œÑ
      p00 = uniqueT W‚ÇÅ W‚ÇÇ

      œà=Œæ : œà == Œæ
      œà=Œæ = cong (‚áí1) p00

      œàœÑ=ŒæœÑ : œà ‚áí œÑ == Œæ ‚áí œÑ
      œàœÑ=ŒæœÑ = cong (_‚áí œÑ) œà=Œæ

      P1 : J‚ü¶ T ‚üßtl == J‚ü¶ WR ‚üßtl
      P1 = cong J‚ü¶_‚üßtl (Jmapt=tl T WR t=wr)


      P4 : J‚ü¶ R ‚üß == J‚ü¶ S ‚üß
      P4 = SingleStep r‚Ü¶s R


      P6 : PathP (Œª i -> C‚ü¶ Œì ‚üß ‚áÅ T‚ü¶ œà=Œæ i ‚üß) J‚ü¶ S ‚üß J‚ü¶ S‚ÇÇ ‚üß
      P6 i = J‚ü¶ JmapT= S S‚ÇÇ œà=Œæ i ‚üß


      P7 : PathP (Œª i -> B Œì (œà=Œæ i)) J‚ü¶ R ‚üß J‚ü¶ S‚ÇÇ ‚üß
      P7 = trans-d {B = B Œì} P4 œà=Œæ P6

      P8 : PathP (Œª i -> B Œì (œàœÑ=ŒæœÑ i)) J‚ü¶ W‚ÇÅ ‚üß J‚ü¶ W‚ÇÇ ‚üß
      P8 i = J‚ü¶ JmapT= W‚ÇÅ W‚ÇÇ œàœÑ=ŒæœÑ i ‚üß

      Q1 : J‚ü¶ U ‚üßtl == J‚ü¶ WS ‚üßtl
      Q1 = cong J‚ü¶_‚üßtl (Jmapt=tl U WS u=ws)


      Q2 : J‚ü¶ snd WR ‚üß == J‚ü¶ snd WS ‚üß
      Q2 i = ‚ü® P8 i , P7 i ‚ü© ‚óá ev

      Q3 = P1 ‚àô Jntl WR ‚àô Q2 ‚àô sym (Jntl WS) ‚àô sym Q1

  in Q3



\end{code}

By combining multiple steps, and then applying the resulting proof to the case of
normalization, the following two corollaries are obtained.

\begin{corollary}
  The interpretation of a well typed term does not change after multiple
  reduction steps.
\begin{code}
MultiStep : ‚àÄ{t u œÑ}  -> {Œì : Ctx n}
                      -> (w : t ‚Ü¶* u)
                      -> (T : Œì ‚ä¢ t :: œÑ) -> (U : Œì ‚ä¢ u :: œÑ)
                      -> J‚ü¶ T ‚üß == J‚ü¶ U ‚üß
\end{code}
\end{corollary}
\begin{code}[hide]
MultiStep {n} {t} {.t} rid T U = cong J‚ü¶_‚üß (Jmapt= T U refl)
MultiStep {n} {t} {u} (x ‚àô‚àò w) T U = SingleStep x T ‚àô MultiStep w (JStep x T) U
\end{code}


\begin{corollary}\label{cor:norsound}
  The interpretation of a term and of its normal form are the same.
\begin{code}
norsound : ‚àÄ{t œÑ}  -> {Œì : Ctx n}
                   -> (T : Œì ‚ä¢ t :: œÑ)
                   -> J‚ü¶ T ‚üß == J‚ü¶ nor‚áì T ‚üß
\end{code}
\end{corollary}
\begin{code}[hide]
norsound {n} {t} {A} {Œì} T =
  let
      u , W , U = nf T

  in MultiStep W T (nfj‚Üë U)
\end{code}
\noindent
Finally, this can be used to show soundness.

\begin{corollary}[Soundness]
  The interpretation is sound with respect to $Œ≤$-equality.
\begin{code}
sound : ‚àÄ{t u œÑ}  -> {Œì : Ctx n}
                  -> (T : Œì ‚ä¢ t :: œÑ) -> (U : Œì ‚ä¢ u :: œÑ)
                  -> (T =Œ≤= U)
                  -> J‚ü¶ T ‚üß == J‚ü¶ U ‚üß
\end{code}
\end{corollary}
\begin{proof}
Since the normal forms $\AF{nor‚áì}\:T$ and $\AF{nor‚áì}\:U$ are equal,
so are their interpretations:
\[
\JJ{\AF{nor‚áì}\:T} = \JJ{\AF{nor‚áì}\:U}
\]
By applying Corollary \ref{cor:norsound} to both sides, this means that
the interpretations of the original terms have to be equal as well:
\[
\JJ{T} = \JJ{U}\qedhere
\]
\end{proof}

\begin{code}[hide]
sound T U p =
  let
    p01 : J‚ü¶ nor‚áì T ‚üß == J‚ü¶ nor‚áì U ‚üß
    p01 = Œª ùíä -> J‚ü¶ nor= T U p ùíä ‚üß

  in norsound T ‚àô p01 ‚àô (sym (norsound U))
\end{code}
